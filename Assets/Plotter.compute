// First stage postprocessing (detection data aggregation)

#pragma kernel Plotter
#include "Common.hlsl"

// Input

RWStructuredBuffer<float2> Poles; //xy pairs
RWStructuredBuffer<float2> Zeroes; //xy pairs
uint NumPoles;
uint NumZeroes;
uint InputSize;
uint PixelZoom;
uint PixelStyle;
float Contours;

// Output buffer

RWTexture2D<float3> Output;

float2 myFunction(float2 z)
{

    if(NumZeroes == 0)
        return z;

    float2 numerator = z - Zeroes[0];

    for(uint i = 1; i < NumZeroes; i++)
    {
        numerator = prod(numerator, (z - Zeroes[i]));
    }
    if(NumPoles == 0)
        return numerator;

    float2 denom = z - Poles[0]; 
    for(uint j = 1; j < NumPoles; j++)
    {
        denom = prod(denom, (z - Poles[j]));
    }
    return div(numerator, denom);

}

float getHue(float2 pos){
    //return 0.4;
    pos = float2(-1.0 + (pos.x * 2.0 / (float)InputSize), -1.0 + (pos.y * 2.0 / (float)InputSize));

    float2 myVal = myFunction(pos);
    float myArg = atan2(myVal[1],myVal[0]);

    return map(myArg,float4(-PI,PI,0.0, 1.0));

}

float findSawTooth(float2 pos){

    if(Contours <= 0.0)
        return 1.0;

    pos = float2(-1.0 + (pos.x * 2.0 / (float)InputSize), -1.0 + (pos.y * 2.0 / (float)InputSize));

    float2 myVal = myFunction(pos);

    float myMod = sqrt((myVal[0]*myVal[0])+(myVal[1]*myVal[1]));

    float myBaseChange = log(myMod)/log(Contours);

    return map(floor(myBaseChange)-myBaseChange,float4(-1.0,0.0,1.0,0.58823));

}

[numthreads(8, 8, 1)]
void Plotter(uint2 id : SV_DispatchThreadID)
{
    bool outputAsBlack = false;
    if(PixelStyle > 0) //0 = no style, 1 = circles, 2 = squares
    {
        float radius = (float)PixelZoom / 2.0;
        float2 center = float2(((uint)id.x / (uint)PixelZoom) * (float)PixelZoom + radius, ((uint)id.y / (uint)PixelZoom) * (float)PixelZoom + radius);
        if(PixelStyle == 1 && distance(id, center) > radius)
            outputAsBlack = true;
        else if(PixelStyle == 2 && (abs(id.x - center.x) > radius * .95 || abs(id.y - center.y) > radius * .95))
            outputAsBlack = true;
    }
    if(outputAsBlack)
        Output[id.xy] = float3(0,0,0);
    else
    {
        float2 pixelXY = float2(((uint)id.x / (uint)PixelZoom) * (float)PixelZoom, ((uint)id.y / (uint)PixelZoom) * (float)PixelZoom);
        Output[id.xy] = findSawTooth(pixelXY) * hue2rgb(getHue(pixelXY)); //hue2rgb(getHue(id));
    }
}
